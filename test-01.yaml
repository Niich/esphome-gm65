substitutions:
  name: "test-01"
  device_description: "esp8266 with UART scanner"
  friendly_name: "mqtt test device"
  bb_server: "barcode-buddy.example.com"
  bbuddy_api_key: "xcvaer234sadfasdf"

esphome:
  name: mqtt-test-01
  includes:
    - uart_read_line_sensor.h

esp8266:
  board: esp01_1m

# Enable logging
logger:
  # level: DEBUG

# # Enable Home Assistant API
# api:
#   encryption:
#     key: "KMOmjQ4WLxmVGW4QT7djjOGdkEyFQEkn7Bo/WwjZ3/w="

ota:
  password: "aa4515dd7b123b94df0324c8b08c7171"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  domain: ".network"

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  # ap:
  #   ssid: "Mqtt-Barcode-Scanner-02"
  #   password: "cvbxcvb"

web_server:
  port: 80
  auth:
    username: !secret web_server_username
    password: !secret web_server_password

# time:
#   - platform: homeassistant
#     id: time_homeassistant
#     on_time_sync:
#       - component.update: sensor_uptime_timestamp
      
# sensor:
  # - platform: uptime
  #   id: sensor_uptime

  # - platform: template
  #   id: sensor_uptime_timestamp
  #   name: "${friendly_name} Uptime"
  #   device_class: "timestamp"
  #   accuracy_decimals: 0
  #   update_interval: never
    # lambda: |-
    #   static float timestamp = (
    #     id(time_homeassistant).utcnow().timestamp - id(sensor_uptime).state
    #   );
    #   return timestamp;

  # - platform: wifi_signal
  #   id: id_wifi_signal
  #   name: ${friendly_name} Signal
  #   update_interval: 60s
    # on_value:
    #     - mqtt.publish_json:
    #         topic: "wifi"
    #         payload: |-
    #           root["id_wifi_signal"] = id(id_wifi_signal).state;
    
# external_components:
#   - source:
#       type: git
#       url: https://github.com/ssieb/custom_components/
#     components: [ serial ]

uart:
    id: uart_scanner
    baud_rate: 9600
    tx_pin: GPIO5
    rx_pin: GPIO4
    stop_bits: 1
    parity: NONE
    data_bits: 8
    debug:
      direction: BOTH
      dummy_receiver: false
      after:
        delimiter: "\n"
      sequence:
        # - lambda: UARTDebug::log_hex(direction, bytes);
        - lambda: UARTDebug::log_binary(direction, bytes, ',');

button:
  - platform: template
    name: Read gm65 config
    id: read_gm65_button

    # Optional variables:
    icon: "mdi:mdi-arrow-left"
    on_press:
      - uart.write:
          id: uart_scanner
          #                             |Zone bits|
          data: [0x7E, 0x00, 0x07, 0x01, 0x00, 0x00, 0x01, 0xAB, 0xCD]

http_request:
  id: bb_request
  useragent: esphome/device
  timeout: 10s

text_sensor:
  - platform: custom
    lambda: |-
      auto my_custom_sensor = new UartReadLineSensor(id(uart_scanner));
      App.register_component(my_custom_sensor);
      return {my_custom_sensor};
    text_sensors:
      id: "uart_readline"
      name: scanner
      on_value:
        then:
        # - mqtt.publish_json:
        #     topic: "scanner"
        #     payload: |-
        #       root["scanner"] = x;
        - http_request.get:
            # Get the current mode set on the server
            url: https://${bb_server}/api/state/getmode
            verify_ssl: false
            headers:
              Content-Type: application/json
              BBUDDY-API-KEY: "${bbuddy_api_key}"
            on_response:
              then:
                - lambda: |-
                    json::parse_json(id(bb_request).get_string(), [](JsonObject root) {
                        auto option = id(mode_select).at(root["data"]["mode"]);
                        auto call = id(mode_select).make_call();
                        call.set_option(option.value());
                        call.perform();
                    });
        
        # - http_request.post:
        #     # Change the server mode to the one our scanner wants
        #     url: "https://${bb_server}/api/state/setmode"
        #     headers:
        #       Accept: "application/json"
        #       Content-Type: 'multipart/form-data; boundary="HGhctEWB8hbsfWCA"'
        #       BBUDDY-API-KEY: "${ bbuddy_api_key }"
        #     body: !lambda |-
        #       return ((std::string) "--HGhctEWB8hbsfWCA\r\nContent-Disposition: form-data; name=\"state\"\r\n" + id(scanner_mode).state ).c_str();
                    
        - http_request.post:
            # Send the scanned code
            url: "https://${bb_server}/api/action/scan"
            verify_ssl: false
            headers:
              Accept: "application/json"
              Content-Type: 'multipart/form-data; boundary="HGhctEWB8hbsfWCA"'
              BBUDDY-API-KEY: "${bbuddy_api_key}"
            body: !lambda |-
              return ((std::string) "--HGhctEWB8hbsfWCA\r\nContent-Disposition: form-data; name=\"barcode\"\r\n" + id(uart_readline).state ).c_str();
 
        # - http_request.post:
        #     # Put the server mode back to what it was before
        #     url: "https://${bb_server}/api/state/setmode"
        #     headers:
        #       Accept: "application/json"
        #       Content-Type: 'multipart/form-data; boundary="HGhctEWB8hbsfWCA"'
        #       BBUDDY-API-KEY: "${ bbuddy_api_key }"
        #     body: !lambda |-
        #       return ((std::string) "--HGhctEWB8hbsfWCA\r\nContent-Disposition: form-data; name=\"state\"\r\n" + id(server_mode).state ).c_str();
        
        - http_request.get:
            # Get the current mode set on the server
            url: https://${bb_server}/api/state/getmode
            verify_ssl: false
            headers:
              Content-Type: application/json
              BBUDDY-API-KEY: "${bbuddy_api_key}"
            on_response:
              then:
                - lambda: |-
                    json::parse_json(id(bb_request).get_string(), [](JsonObject root) {
                        auto option = id(mode_select).at(root["data"]["mode"]);
                        auto call = id(mode_select).make_call();
                        call.set_option(option.value());
                        call.perform();
                    });

  # - platform: template
  #   id: server_mode
  #   name: "server mode"
  # - platform: template
  #   id: scanner_mode
  #   name: "scanner mode"
  #   lambda: |-
  #     return {"2"};

select:
  - platform: template
    id: mode_select
    name: "Mode select"
    options:
      - CONSUME
      - CONSUME_SPOILED
      - PURCHASE
      - OPEN
      - GETSTOCK
      - ADD_SL
      - CONSUME_ALL
    initial_option: CONSUME
    optimistic: true
    on_value:
      then:
        # - if: 
        #     condition: 
        #       lambda: return x != id(mode_select).state;
        #     then:
        - http_request.post:
            # Change the server mode to the one our scanner wants
            url: "https://${bb_server}/api/state/setmode"
            verify_ssl: false
            headers:
              Accept: "application/json"
              Content-Type: 'multipart/form-data; boundary="HGhctEWB8hbsfWCA"'
              BBUDDY-API-KEY: "${bbuddy_api_key}"
            body: !lambda |-
              char buffer[20];
              itoa(id(mode_select).index_of(x).value(), buffer, 10);
              return ((std::string) "--HGhctEWB8hbsfWCA\r\nContent-Disposition: form-data; name=\"state\"\r\n" + buffer ).c_str();
        # - http_request.get:
        #     # Get the current mode set on the server
        #     url: https://${bb_server}/api/state/getmode
        #     headers:
        #       Content-Type: application/json
        #       BBUDDY-API-KEY: "${ bbuddy_api_key }"
        #     verify_ssl: false
        #     on_response:
        #       then:
        #         - lambda: |-
        #             json::parse_json(id(bb_request).get_string(), [](JsonObject root) {
        #                 auto option = id(mode_select).at(root["data"]["mode"]);
        #                 auto call = id(mode_select).make_call();
        #                 call.set_option(option.value());
        #                 call.perform();
        #                 id(server_mode).publish_state(root["data"]["mode"]);
        #                   });
    # set_action:
    #   then:
    # lambda: |-
    #   return x;


# mqtt:
#   id: mqtt_client
#   topic_prefix: esp-mqtt
#   broker: !secret mqtt_server
#   username: !secret mqtt_user
#   password: !secret mqtt_password
  
#   on_message:
#     - topic: scanner
#       qos: 0
#       then:
#         - text_sensor.template.publish:
#             id: mqtt_scanner
#             state: !lambda |-
#               return x;
#     - topic: wifi
#       qos: 0
#       then:
#         - text_sensor.template.publish:
#             id: mqtt_wifi
#             state: !lambda |-
#               return x;

          
